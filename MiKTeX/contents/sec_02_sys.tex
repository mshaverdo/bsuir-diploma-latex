\lstset{style=pythoninlinestyle}

\section{СИСТЕМНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:sys}

\subsection{Постановка задачи на разработку программного средства}
\label{sub:sys:1}

В классической постановке, пусть задано k входных и выходных   переменных (для примера - три входных переменных x, y, z и одна выходная переменная w). Пусть определены лингвистические значения этих переменных A,B,C,D,E,F для n правил (для примера n=3).  Типичный вариант представления логического вывода, с этапами фаззификации,  агрегирования и дефаззификации показан на рис. 2.1.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.3]{2-1.png}
  \caption{Вариант представления логического вывода, с этапами фаззификации,  агрегирования и дефаззификации }
  \label{fig:sys:1:1}
\end{figure}

Точные исходные данные с датчиков, контролирующих управляющий процесс, переводятся в значения лингвистических переменных в специальном блоке фаззификатора. Далее реализуются процедуры нечеткого вывода на множестве продукционных правил, составляющих базу знаний системы управления, в результате чего формируются выходные лингвистические значения, которые переводятся в точные значения результатов вычислений в блоке дефаззификатора. На выходе последнего формируются управляющие воздействия на исполнительные механизмы. Эта концептуальная схема лежит в основе нечеткого контроллера. И выполнение работы каждого блока нечеткого контроллера требует достаточного выделения ресурсов и времени на выполнение задач. [4]

Для отладки нечеткого контроллера могут применяться натурные эксперименты, но их проведение сопряжено со значительными временными и финансовыми, сложностью доступа к оборудованию, формированию полигона, погодных условия и так далее. Логичным решением этой проблемы представляется программное моделирование экспериментов, что позволяет значительно упростить, ускорить и удешевить настройку и отладку нечетких контроллеров. Многие реализации нечетких контроллеров основаны на классических алгоритмах, поэтому разрабатываемое программное средство должно содержать гибко настраиваемую реализацию одного из классических алгоритмов нечеткого вывода, на основе которого экспериментатор сможет реализовать собственный нечеткий контроллер. Поскольку нечеткие контроллеры — это активно развивающееся направление, разрабатываемое программное средство должно позволять с минимальными трудозатратами подключать реализованные экспериментатором алгоритмы нечетких контроллеров. Визуализация результатов эксперимента в виде графиков и диаграмм обычно требует установки, настройки и освоение стороннего программного обеспечения, поэтому разрабатываемое программное средство должно позволять отображать результаты экспериментов. Настройка алгоритмов нечеткого вывода является трудоемкой, поэтому программное средство должно иметь средства автоматизации обучения нечетких контроллеров.

Таким образом можно сформулировать требования к программному средству для отладки алгоритмов нечеткого управления мобильными роботами:

\begin{itemize}
  \item содержать в себе готовую, настраиваемую модель нечеткого контроллера на базе классического алгоритма нечеткого вывода;
  \item иметь возможность подключения реализованных экспериментатором моделей нечетких контроллеров;
  \item позволять гибко настраивать конфигурацию и характеристики моделируемого пути;
  \item иметь возможность визуализации, сравнения и сохранения полученных в результате эксперимента данных;
  \item иметь средства автоматизированной генерации лингвистических переменных, термов и правил нечетких алгоритмов;
  \item быть доступной для освоения в короткие сроки.
\end{itemize}

\subsection{Разработка обобщенной модели}
\label{sub:sys:2}

Обобщенная схема эксперимента представлена на чертеже ГУИР ГУИР.400201.322 С2. Опишем ее блоки.

\subsubsection{Ввод $S_0$, $V_0$}

В начале эксперимента в качестве исходных данных задаются начальная скорость $V_0$ и начальное расстояние до препятствия $S_0$.

\subsubsection{Расчет усилия }

Каждый квант модельного времени производится расчет тормозного усилия. Расчет производится нечетким алгоритмом на основании текущей скорости, текущего расстояния до препятствия, заданных термов лингвистических переменных и базы правил. Последние получены в результате работы алгоритма настройки и обучения.

\subsubsection{ Моделирование замедления}

На основании расчетного усилия  замедления и характеристик моделируемого пути в данной точке рассчитывается значение отрицательного ускорения, которое будет действовать на платформу в текущий момент модельного времени.

\subsubsection{Расчет мгновенных V`, S` для текущего модельного времени T}

На основании рассчитанного в п. 2.1.3 ускорения, а также расстояния и пути S и V для предыдущего кванта модельного времени, рассчитываются новые значения V` и S` для текущего модельного времени.

\subsubsection{ S = 0 или V = 0? }
Здесь выполняется проверка: если расстояние до препятствия равно нулю, либо мгновенная скорость равна нулю, эксперимент окончен, иначе повторения цикла. Действительно: если скорость равна нулю, то, очевидно, дальнейшее положение платформы не изменится, она успешно остановилась. Верно и другое: если расстояние до препятствия равно нулю, значит произошло столкновение.

\subsubsection{ Алгоритм настройки и обучения }

Области определения лингвистических переменных, функции принадлежности термов, а также правила задаются в результате работы алгоритма настройки и обучения. Проектируемое программное средство позволяет задавать вышеупомянутые переменные и правила в автоматизированном режиме на основе эталонных данных.

\subsection{Методика тестирования и отладки алгоритмов нечеткого управления; алгоритм настройки нечеткого контроллера}

Основной проблемой создания нечеткого регулятора является конструирование базы знаний, содержащей опыт и знания человека – оператора. Заполнение базы знаний может выполняться различными способами [9]:

\begin{itemize}
  \item Оператор-эксперт управляет технологическим процессом, за которым <<наблюдает>> регулятор, запоминая все действия эксперта и заполняя свою базу знаний.
  \item Оператор-эксперт описывает свое действие при каждой наблюдаемой ситуации в виде продукции <<если..., то... >>, которые и будут образовывать базу знаний регулятора.
  \item Перед самоорганизующимся нечетким регулятором ставится цель обеспечить желаемую переходную характеристику проектируемой системы и одновременно сообщается некоторая информация о технологическом процессе (объекте управления). Регулятор самостоятельно (методом проб и ошибок) накапливает знания без эксперта.
\end{itemize}

Кроме рассмотренной структуры возможны и более сложные, способные адаптировать к изменениям окружающей среды путем переключений на другие множества лингвистических значений, продукционные правила, базы знаний [10].

При реализации данного программного средства использовалась комбинация первого и второго подходов: на основании собранных данных в результате моделирования с применением <<наивного>> алгоритма, блок обучения нечеткого контроллера генерирует предварительный набор правил, которые затем донастраиваются оператором (экспертом).

\subsection{Структурная схема экспериментального программного обеспечения}
\label{sub:sys:4}

Изучив теоретические аспекты разрабатываемой системы и выработав список требований необходимых для разработки системы, разбиваем систему на функциональные блоки(модули). Это необходимо для обеспечения гибкой архитектуры. Такой подход позволяет изменять или заменять модули без изменения всей системы в целом.

В разрабатываемом приложении можно выделить следующие блоки:

\begin{itemize}
  \item блок пользовательского интерфейса;
  \item блок диспетчера приложения;
  \item блок обучения нечетких контроллеров;
  \item блок визуализации телеметрии;
  \item блок симуляции;
  \item блок физической модели;
  \item блок моделирования нечетких алгоритмов;
  \item блок моделирования телеметрии.
\end{itemize}

Структурная схема, иллюстрирующая перечисленные блоки и связи между ними приведена на чертеже ГУИР.400201.322 С1.

Каждый модуль выполняет свою задачу. Чтобы система работала каждый модуль взаимодействует с другими модулями путем обмена данными, используя различные форматы и протоколы.

Рассмотрим функциональные блоки приложения.

\textit{Блок пользовательского интерфейса} реализует интерфейс командной строки (CLI). Для профессионального научного ПО CLI имеет ряд преимуществ:

\begin{itemize}
  \item Легкость автоматизации. Shell script в UNIX-подобных системах является полноценным интерпретируемым языком программирования и способен автоматизировать любую системную задачу.
  \item Возможность запуска ПО на удаленном высокопроизводительном сервере, что, как правило, невозможно для программ с графическим интерфейсом.
  \item Возможность пользоваться удаленным компьютером с любого устройства подключаемого к Интернету или локальной сети (ПК, субноутбук, КПК, сотовый телефон, портативная игровая консоль) без особых затрат трафика (единицы килобайт за сеанс).
\end{itemize}


\textit{Блок диспетчера приложения} представляет из себя классический контроллер в парадигме MVC (Модель-Представление-Контроллер).  MVC — это паттерн проектирования веб-приложений, который включает в себя несколько более мелких шаблонов. При использовании MVC модель данных приложения, пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента, благодаря чему модификация одного из них оказывает минимальное воздействие на остальные или не оказывает его вовсе.

Основная цель применения MVC состоит в разделении данных и бизнес-логики от визуализации (внешнего вида). За счет такого разделения повышается возможность повторного использования программного кода и упрощается сопровождение (изменения внешнего вида, например, не отражаются на бизнес-логике).

Концепция MVC разделяет данные, представление и обработку действий пользователя на компоненты:

Модель (Model) — предоставляет собой объектную модель некой предметной области, включает в себя данные и методы работы с этими данными, реагирует на запросы из контроллера, возвращая данные и/или изменяя своё состояние, при этом модель не содержит в себе информации, как данные можно визуализировать, а также не «общается» с пользователем напрямую.

Представление (View) — отвечает за отображение информации (визуализацию), одни и те же данные могут представляться различными способами, например, коллекцию объектов при помощи разных «View» можно представить как в табличном виде, так и списком.

Контроллер (Controller) — обеспечивает связь между пользователем и системой, использует модель и представление для реализации необходимой реакции на действия пользователя, как правило, на уровне контроллера осуществляется фильтрация полученных данных и авторизация (проверяются права пользователя на выполнение действий или получение информации).



\textit{Блок обучения нечетких алгоритмов} реализует автоматизированную генерацию термов лингвистических переменных и правил для нечетких алгоритмов. Генерация происходит на основании предварительно собранной телеметрии, полученной в ходе «эталонных» моделирований с применением традиционных алгоритмов. В процессе генерации базы лингвистических переменных и правил происходит разбиение области значений входных и выходных переменных на заданное пользователем количество частей, генерация термов на основании этого разбиения. Затем анализируется весь массив данных телеметрии, на основании чего выводятся правила алгоритмов нечеткой логики. При необходимости, пользователь производит точную донастройку вручную. Результаты генерации сохраняются в JSON файл. Преимуществом формата JSON является то, что он одновременно легко читается как машинами, так и людьми в любом текстовом редакторе.

\textit{Блок визуализации телеметрии} предназначен для визуализации собранной в результате экспериментов телеметрии. Позволяет отображать изменяющиеся во времени параметры модели в виде графиков, позволяет сравнивать графики разных экспериментов. Реализован с применением общепринятой для научной графики библиотеки Matplotlib. Matplotlib — библиотека на языке программирования Python для визуализации данных двумерной (2D) графикой (3D графика также поддерживается). Получаемые изображения могут быть использованы в качестве иллюстраций в публикациях.

\textit{Блок симуляции} управляет симуляцией физической модели, алгоритма контроллера и сбором телеметрии. Концептуально является диспетчером подсистемы симуляции. Блок симуляции задает грануляцию модельного времени, инициализирует физическую модель и конфигурирует путь мобильной платформы. Через него осуществляется коммуникация между блоками более нижних уровней, и главным контроллером приложения. Кроме того, блок симуляции отвечает за генерацию и синхронизацию квантов модельного времени между блоками физической модели, моделирования нечетких алгоритмов и сбора телеметрии.

\textit{Блок физической модели} отвечает за изменение параметров движения мобильной платформы с учетом управляющих сигналов, исходящих от нечеткого контроллера, конфигурации пути и инерционности системы управления. Реализация физической модели позволяет гибко настраивать параметры участков пути, устанавливая следующие параметры:

\begin{itemize}
  \item   Границы участка. Отметки расстояния от точки торможения, задающие конфигурируемый участок.
  \item   Константное добавочное ускорение. Позволяет моделировать наклонные участки пути.
  \item   Максимальное применяемое ускорение. Позволяет моделировать ограничения коэффициента сцепления с дорогой: обледенелые, мокрые, изношенные участки пути.
\end{itemize}


Границы участков могут пересекаться и накладываться друг на друга, в этом случае ограничения участков будут применяться «послойно». Это позволяет легко задавать, например, коэффициент ускорения на всем протяжении пути, выделяя отдельные «обледенелые» участки.

Инерционность системы управления позволяет моделировать задержки в реакции системы управления, вызванные, например, ограниченным быстродействием пневмогидравлической системы торможения.

\textit{Блок моделирования нечетких алгоритмов} непосредственно отвечает за моделирование контроллера мобильной платформы. Благодаря универсальному API возможно подключение разных реализаций как нечетких, так и традиционных контроллеров. В качестве входных данных блок моделирования получает значения модельных текущей скорости, ускорения и расстояния до цели и на основании этого генерирует выходные данные – значение тормозного усилия, которое затем будет применено при расчёте фактического ускорения (замедления) платформы в блоке физической модели. Вместе с системой поставляются несколько базовых версий контроллера: «наивный» контроллер, контроллер на базе классического алгоритма Мамдани, а также контроллер на базе ускоренного алгоритма Мамдани. «Наивный» контроллер используется для расчета эталонных значений телеметрии в идеальных условиях для дальнейшего обучения нечетких алгоритмов.

\textit{Блок моделирования телеметрии }предназначен для сбора параметров физической модели для каждого кванта модельного времени. Для задачи плавной остановки платформы собирает мгновенные расстояние до цели, скорость, ускорение и рывок, привязанные к модельному времени.

Телеметрия может быть визуализирована непосредственно после окончания моделирования, либо сохранена для последующих визуализации и анализа. Данные выгружаются в формате CSV, что позволяет оперировать ими в большом количестве стороннего ПО. CSV (от англ. Comma-Separated Values — значения, разделённые запятыми) — текстовый формат, предназначенный для представления табличных данных. Каждая строка файла — это одна строка таблицы. Разделителем (англ. delimiter) значений колонок является символ запятой (,). Однако на практике часто используются другие разделители. Значения, содержащие зарезервированные символы (двойная кавычка, запятая, точка с запятой, новая строка) обрамляются двойными кавычками ("). Если в значении встречаются кавычки — они представляются в файле в виде двух кавычек подряд.
